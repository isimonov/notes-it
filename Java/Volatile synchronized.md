# Сходство volatile и synchronized

Блокировка с использованием слова synchronized это не только барьер который позволяет выполнять некий код только одним потоком. Но и видимость изменений в памяти. Когда поток А выполняет synchronized блок и затем поток Б входит в synchronized блок защищенный тем же самым локом, значения переменных которые были видны в А до освобождения лока, гарантировано будут видны потоку Б после получения лока. Без синхронизации нет такой гарантии.

Тоже самое происходит и с volatile. Когда поток А пишет в volatile переменную и поток Б затем считывает тоже самое значение, то значения всех переменных которые были видны потоку А до начала записи, становятся видимыми потоку Б уже после чтения этой переменной.
Автор книги (Java Concurrency in Practice) не рекомендует слишком полагаться на видимость volatile переменных. Поскольку такой код более хрупкий и менее понятный чем тот который использует synchronized.

Какая разница между использованием volatile и synchronized?
Ну во первых стоит отметить что в отличии от synchronized, volatile не блокирует другие потоки. И является более легковесным инструментом для синхронизации.

Также стоит упомянуть о том, что операции присваивания и чтения ссылочных переменных и переменных примитивных типов за исключением long и double это атомарные операции. Volatile позволяет рассматривать данные операции как атомарные даже для переменных типа long и double.

Volatile не может сделать операцию инкремента i++ атомарной (если поле i помечено как volatile). Но synchronized может если обвернет этот код.

Synchronized может гарантировать видимость для других потоков и атомарность операций, а volatile только видимость!

# Рекомендация автора книги (Java Concurrency in Practice).

"Используйте volatile только тогда когда это упрощает реализацию логику синхронизации; избегайте использования volatile переменных когда проверка правильности кода требует тонкого понимания нюансов видимости. Пример правильного использования. Например когда требуется проверка состояния объекта хранящего данную переменную или для того чтобы сигнализировать о том что случилось некое действие относящееся к жизненному циклу объекта. Например инициализация или утилизация".

# Когда следует использовать volatile?

Когда выполняются все из ниже приведенных условий:
1) Все что будет записано в переменную не зависит от текущего значения, или вы уверены что только один поток может изменять это значение. Тут думаю все понятно. Это предостерегает нас от использования volatile например для счетчика т.к. операция инкремента не атомарная и нам все равно потребуется synchronized.

2) Переменная не участвует в некоторых постоянных связях между переменными являющимися состоянием объекта на протяжении его всего жизненного цикла. Поясню. У нас есть класс TimeInterval. Постоянной связью между переменными тут будет то что start < end - всегда! Если эти переменные volatile то вы можете полагаться на их видимость, но не на то что во время их изменения условие start < end будет выполняться. Volatile не достаточно - значит нам нужен synchronized.
3) Если нам не нужно ограничивать некоторое действие над переменной от других потоков. Volatile не может нам предоставить возможность как synchronized обвернуть код и ограничить к нему доступ для других потоков.