Модель памяти в Java, используемая внутри JVM, делит память на стеки потоков (thread stacks), кучу (heap) и Metaspace (замена PermGen в Java 8 и выше).


# Стек потока

Каждый поток в Java имеет собственный стек, который содержит информацию о вызовах методов и локальных переменных. Стек устроен по [принципу LIFO](https://ru.wikipedia.org/wiki/LIFO) (last-in, first-out) и используется для управления выполнением методов и их локальными переменными.

Каждый вызов метода создает новый фрейм стека, который содержит локальные переменные метода, параметры и информацию о выполнении. После завершения метода фрейм стека удаляется, освобождая память.

Поток может получить доступ только к своему стеку. Локальные переменные не видны остальным потокам, только потоку, создавшему их. В ситуации, когда два потока выполняют один и тот же код, они оба создают свои локальные переменные. Таким образом, каждый поток имеет свою версию каждой локальной переменной.

Размер стека ограничен и может быть настроен при запуске JVM. Если стек переполнен (обычно из-за глубокой или бесконечной рекурсии), JVM выбросит [исключение](https://stackoverflow.com/questions/3197708/what-causes-a-java-lang-stackoverflowerror) `java.lang.StackOverflowError`.
## Особенности

1. **LIFO (Last-In, First-Out)**: Стек работает по принципу "последним пришел - первым ушел". Это означает, что последняя функция, которая была вызвана, будет первой, которая вернет управление обратно.
2. **Автоматическое управление памятью**: Как только функция завершает свою работу, все локальные переменные автоматически удаляются. Это облегчает управление памятью, поскольку нет необходимости явно освобождать память.
3. **Ограниченный размер**: Размер стека обычно ограничен. Если программа пытается использовать больше стековой памяти, чем доступно, это вызовет ошибку переполнения стека.
4. **Быстрый доступ**: Доступ к данным в стеке обычно быстрее, чем к данным в куче, поскольку стек локализован в памяти и данные из стека могут быть загружены в кэш процессора для быстрого доступа.


# Куча

Куча содержит все объекты, созданные в вашем приложении, независимо от того, какой поток создал объект. К этому относятся и обертки примитивных типов (например, Byte, Integer, Long и так далее). Неважно, был ли объект создан и присвоен локальной переменной или создан как переменная-член другого объекта, он хранится в куче.
## Особенности

1. **Динамическое распределение памяти**: Куча позволяет программе динамически запросить точное количество памяти, которое ей нужно, и использовать эту память до тех пор, пока она не решит, что больше ее не нужно.
2. **Долговечность данных**: Поскольку память не освобождается автоматически, как в стеке, данные в куче могут существовать до тех пор, пока не будут освобождены, что позволяет им пережить вызовы функций и даже полное выполнение программы.
3. **Управление памятью**: Работа с кучей требует аккуратного управления памятью. Утечки памяти могут стать проблемой, если программист не освобождает память, когда она больше не нужна.
4. **Медленный доступ**: В сравнении со стеком, доступ к данным в куче может быть медленнее из-за отсутствия локализации и больших размеров данных.

## Сборка мусора

Для сборки мусора используется алгоритм пометок (Mark & Sweep). Этот алгоритм состоит из трех этапов:

1. **Mark (маркировка)**. На первом этапе GC сканирует все объекты и помечает живые (объекты, которые все еще используются). На этом шаге выполнение программы приостанавливается. Поэтому этот шаг также называется "Stop the World" .
2. **Sweep (очистка)**. На этом шаге освобождается память, занятая объектами, не отмеченными на предыдущем шаге.
3. **Compact (уплотнение)**. Объекты, пережившие очистку, перемещаются в единый  непрерывный блок памяти. Это уменьшает фрагментацию кучи и позволяет проще и быстрее размещать новые объекты.

### Поколения объектов

Для оптимизации сборки мусора память кучи дополнительно разделена на четыре области. В эти области объекты помещаются в зависимости от их возраста (как долго они используются в приложении).

1. **Young Generation (молодое поколение)**. Здесь создаются новые объекты. Область young generation разделена на три части раздела: Eden (Эдем), S0 и S1 (Survivor Space — область для выживших).
2. **Old Generation (старое поколение)**. Здесь хранятся давно живущие объекты.

### Сборка мусора детально

1. Новые объекты создаются в области Eden. Области Survivor (S0, S1) на данный момент пустые.
2. Когда область Eden заполняется, происходит **минорная сборка мусора (Minor GC)**. Minor GC - это процесс, при котором операции mark и sweep выполняются для young generation (молодого поколения).
3. После Minor GC живые объекты перемещаются в одну из областей Survivor (например, S0). Мертвые объекты полностью удаляются.
4. По мере работы приложения пространство Eden заполняется новыми объектами. При очередном Minor GC области young generation и S0 очищаются. На этот раз выжившие объекты перемещаются в область S1, и их возраст увеличивается (отметка о том, что они пережили сборку мусора).
5. При следующем Minor GC процесс повторяется. Однако на этот раз области Survivor меняются местами. Живые объекты перемещаются в S0 и у них увеличивается возраст. Области Eden и S1 очищаются.
6. Объекты между областями Survivor копируются определенное количество раз (пока не переживут определенное количество Minor GC) или пока там достаточно места. Затем эти объекты копируются в область Old.
7. Major GC. При **Major GC** этапы mark и sweep выполняются для Old Generation. Major GC работает медленнее по сравнению с Minor GC, поскольку старое поколение в основном состоит из живых объектов.

### Типы сборщиков мусора

- **Serial** - Использует один поток. Эффективный, т.к. нет накладных расходов на взаимодействие потоков. Однопроцессорные машины. Работа с небольшими наборами данных.
- **Parallel** - Использует несколько потоков. Многопоточность ускоряет сборку мусора. В приоритете пиковая производительность. Допустимы паузы при GC в одну секунду и более. Работа со средними и большими наборами данных.
- **CMS** - Низкие паузы GC. Возможная фрагментация памяти, сложность. Интерактивные приложения. Не популярный.
- **G1** - Выполняет некоторую тяжелую работу параллельно с работой приложения. Может использоваться как на небольших системах, так и на больших с большим количеством процессоров и большим количеством памяти. Когда время отклика важнее пропускной способности. Паузы GC должны быть меньше одной секунды.
- **ZGC** - В текущей реализации работает с одним поколением. Есть планы добавить несколько поколений. Выполняет всю тяжелую работу параллельно с работой приложения. Низкая задержка. В приоритете время отклика. Максимальное время паузы при работе ZGC редко превышает 250 микросекунд.
- **Epsilon** - Пассивный или «нерабочий» сборщик, что означает, что он обрабатывает выделение памяти, но не перерабатывает ее! Итак, когда в куче заканчивается память, JVM просто выключается. Устраняет влияние сборщика мусора и позволяет запускать приложение изолированно. Но это требует очень четкого понимания требований к памяти для нашего приложения.

[Сборщики мусора](https://habr.com/ru/articles/680038/)


# Metaspace (замена PermGen в Java 8 и выше)

Metaspace используется для хранения метаданных классов и методов, в отличие от PermGen (специальное место в куче, отделенное от основной памяти), который был удален в Java 8. В отличие от PermGen, Metaspace расширяется динамически, что помогает избежать ошибок `OutOfMemoryError`, связанных с метаданными классов.

Хотя Metaspace расширяется динамически, его максимальный размер все равно можно контролировать с помощью параметров JVM, что позволяет управлять потреблением памяти для метаданных.
