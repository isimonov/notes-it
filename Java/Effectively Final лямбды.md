# Final

Переменные объявленные как `final` не могут меняться после инициализации.

# Effectively Final

Переменные которые не были объявлены, как `final`, но при этом, после инициализации не меняют значения, являются т.н. *"effectively final"* переменными. Effectively final переменная может быть использована в лямбда-выражениях и анонимных классах, так как Java гарантирует, что ее значение не будет изменено.

# Захват переменных в лямбде

Захваченная локальная (уровня метода) переменная в лямбде (и анонимном классе?) обязана быть `final` или effectively final. Такое требование исходит из следующих причин.
  
Локальная переменная хранится на стеке, а значит время ее жизни в отличие от долгоживущих элементов хипа ограничено скоупом и текущим потоком. Но экземпляр лямбды, захвативший эту переменную, мог бы быть передан наружу и использован для доступа к этой переменной _из другого потока_ и _после выхода из метода_.  
  
Эта проблема решается тем, что в лямбду _копируется_ значение локальной переменной. Такая копия живет независимо, возможно дольше оригинала. Но это решение приведет к сложному поведению из-за возможности работы с неактуальным значением – копия и оригинал станут двумя разными переменными. Поэтому значение должно быть вечно актуально – неизменяемо.  
  
Поля экземпляра (уровня класса) менять можно, потому что захваченной переменной в этом случае выступает effectively final значение `this`. 

# Изменение локальной переменной в лямбде

Если локальную переменную всё же хочется изменить, решение очевидно – поместить её в кучу. Для этого нужно использовать любого рода обертку: одноэлементный массив, объект-atomic, специально созданный класс с этой переменной как полем.  

> [!Избегайте обходных путей]
> Хак с оберткой решает проблему времени жизни и даёт коду скомпилироваться, но возвращает проблему сложности поведения. Если среда многопоточная, то вероятно порядок операций с этой переменной придется синхронизировать вручную.

Рассмотрим пример, который использует массив для хранения переменной в однопоточном приложении.

```java
  
public int workaroundSingleThread() {  
	int[] holder = new int[] { 2 };  
	IntStream sums = IntStream  
		.of(1, 2, 3)  
		.map(val -> val + holder[0]);  
  	holder[0] = 0;  
	return sums.sum();  
}
```

Мы могли бы подумать, что поток суммирует 2 с каждым значением, но **на самом деле он суммирует 0, поскольку это самое последнее значение, доступное при выполнении лямбда-выражения.**

Сделаем еще один шаг и выполним сумму в другом потоке.

```java
public void workaroundMultithreading() {  
    int[] holder = new int[] { 2 };  
    Runnable runnable = () -> System.out.println(IntStream  
        .of(1, 2, 3)  
        .map(val -> val + holder[0])  
        .sum());  
  
    new Thread(runnable).start();  
  
    // simulating some processing  
    try {  
        Thread.sleep(new Random().nextInt(3) * 1000L);  
    } catch (InterruptedException e) {  
        throw new RuntimeException(e);  
    }  
  
    holder[0] = 0;  
}
```

Какое значение мы здесь суммируем? Это зависит от того, сколько времени займет наша смоделированная обработка. **Если он достаточно короткий, чтобы выполнение метода завершилось до того, как будет выполнен другой поток, он напечатает 6, в противном случае он напечатает 12.**

Как правило, такие обходные пути подвержены ошибкам и могут привести к непредсказуемым результатам, поэтому их всегда следует избегать.

#Java/final #Java/lambda