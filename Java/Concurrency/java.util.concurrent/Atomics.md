Классы, которые могут поддерживать атомарные операции над примитивами и ссылками. Атомарные классы активно используют [сравнение с обменом](https://ru.wikipedia.org/wiki/%D0%A1%D1%80%D0%B0%D0%B2%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D0%B1%D0%BC%D0%B5%D0%BD%D0%BE%D0%BC) (compare-and-swap, CAS), атомарную инструкцию, которую поддерживает большинство современных процессоров. Эти инструкции работают гораздо быстрее, чем синхронизация с помощью блокировок. Поэтому, если вам просто нужно изменять одну переменную с помощью нескольких потоков, лучше выбирать атомарные классы. 

```c
/* Псевдокод работы инструкции CAS */
int cas(int* addr, int old, int new)
{
  if ( *addr != old )
    return 0;

  *addr = new;
  return 1;
}
```

Atomics можно разделить на 4 группы.

# Atomic boolean, integer, long и ссылки

- AtomicBoolean
- AtomicInteger
- AtomicLong
- AtomicReference

Классы этой группы содержат метод **compareAndSet**, принимающий 2 аргумента : предполагаемое текущее и новое значения. Метод устанавливает объекту новое значение, если текущее равно предполагаемому, и возвращает true. Если текущее значение изменилось, то метод вернет false и новое значение не будет установлено.  

Кроме этого, классы имеют метод **getAndSet**, который безусловно устанавливает новое значение и возвращает старое.  

Классы AtomicInteger и AtomicLong имеют также методы инкремента/декремента/добавления нового значения.

# Atomic массивы integer, long и ссылок

- AtomicIntegerArray
- AtomicLongArray
- AtomicReferenceArray

Элементы массивов могут быть изменены атомарно.

# Классы для обновления полей с использованием reflection

- AtomicIntegerFieldUpdater
- AtomicLongFieldUpdater
- AtomicReferenceFieldUpdater

Гарантии метода CompareAndSet в этих классах слабее, чем в других атомарных классах. Поскольку эти классы не могут гарантировать, что все виды использования поля подходят для целей атомарного доступа, он может гарантировать атомарность только в отношении других вызовов метода CompareAndSet, установленных в том же средстве обновления.

# Atomic-классы для реализации некоторых алгоритмов

- AtomicStampedReference - предоставляет нам как переменную ссылки на объект, так и штамп, который мы можем читать и записывать атомарно. Мы можем думать о штампе как о временной отметке или номере версии. Добавление штампа позволяет нам обнаружить, когда другой поток изменил общую ссылку с исходной ссылки A на новую ссылку B и обратно на исходную ссылку A.
- AtomicMarkableReference - инкапсулирует как ссылку на объект , так и логический флаг. Эти два поля связаны друг с другом и могут обновляться атомарно , либо вместе, либо по отдельности. Также класс может быть возможным решением [проблемы ABA](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_ABA).