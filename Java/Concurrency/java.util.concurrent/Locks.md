Гибкие механизмы синхронизации потоков по сравнению с базовыми `synchronized`, `wait`, `notify`, `notifyAll`. Классы блокировок реализуют интерфейс `Lock`, который определяет следующие методы:

- `void lock()`: ожидает, пока не будет получена блокировка
- `void lockInterruptibly() throws InterruptedException`: ожидает, пока не будет получена блокировка, если поток не прерван
- `boolean tryLock()`: пытается получить блокировку, если блокировка получена, то возвращает true. Если блокировка не получена, то возвращает false. В отличие от метода `lock()` не ожидает получения блокировки, если она недоступна
- `void unlock()`: снимает блокировку
- `Condition newCondition()`: возвращает объект Condition, который связан с текущей блокировкой

# ReentrantLock

 Реентерабельная блокировка. Реентрабильность - программа разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами

```java
private final Lock R_LOCK = ReentrantLock();
R_LOCK.lock();
try { //тут происходят какие-то действия }
finally { R_LOCK.unlock(); }
```

# ReadWriteLock

`ReadWriteLock` - интерфейс для создания read/write локов. Локи необычайно полезны, когда в системе много операций чтения и мало операций записи. `ReadWriteLock` имеет два основных метода: `readLock()` и `writeLock()`.

## ReentrantReadWriteLock

`ReentrantReadWriteLock` - используется в многопоточных сервисах и кешах, имеют хороший прирост производительности по сравнению с блоками synchronized. По сути, класс работает в 2-х взаимоисключающих режимах: много читателей читают данные в параллель и когда только 1 райтер пишет данные.