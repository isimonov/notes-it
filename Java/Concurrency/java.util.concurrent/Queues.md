Неблокирующие и блокирующие очереди для работы в многопоточной среде. Неблокирующие очереди сосредоточены на скорости и работе без блокирования потоков. Блокирующие очереди подходят для работы, когда нужно "притормозить" потоки Producer или Consumer. Например, в той ситуации, когда не выполнены какие-то из условий, очередь пуста или переполнена, или же нет свободного Consumer'a.

# Non-Blocking Queues

Потокобезопасные и самое важное неблокирующие имплементации `Queue` на связанных нодах (linked nodes).

## ConcurrentLinkedQueue

Используется wait-free алгоритм, адаптированный для работы с garbage collector'ом. Этот алгоритм довольно эффективен и очень быстр, так как построен на CAS (compare and set). Метод `size()` может работать долго, так что лучше постоянно его не дергать.

## ConcurrentLinkedDeque

Deque расшифровывается как Double ended queue. Это означает, что данные можно добавлять и вытаскивать с обеих сторон. Соответственно, класс поддерживает оба режима работы: FIFO (First In First Out) и LIFO (Last In First Out).

На практике `ConcurrentLinkedDeque` стоит использовать в том случае, если обязательно нужно именно LIFO, так как за счет двунаправленности нод данный класс проигрывает по производительности наполовину по сравнению с `ConcurrentLinkedQueue`.

# Blocking Queues

Интерфейс `BlockingQueue<\E>` используется при большом количестве данных, когда `ConcurrentLinkedQueue` не хватает.

Когда потоки не справляются с поставленной задачей, ты легко можешь получить `OutOfMemmoryException`. И чтобы такие случаи не возникали, у нас для работы есть `BlockingQueue` c наличием разных методов для заполнения и работы с очередью и блокировками по условиям.

`BlockingQueue` не признает нулевых элементов (null) и вызывает `NullPointerException` при попытке добавить или получить такой элемент.

## ArrayBlockingQueue

Класс блокирующей очереди, построенный на классическом кольцевом буфере. Здесь нам доступна возможность управлять "честностью" блокировок. Если fair=false (по умолчанию), то очередность работы потоков не гарантируется.

## DelayQueue

Класс, который позволяет вытаскивать элементы из очереди только по прошествии некоторой задержки, определенной в каждом элементе через метод `getDelay` интерфейса `Delayed`.

## LinkedBlockingQueue

Блокирующая очередь на связанных нодах, реализованная на “two lock queue” алгоритме: первый лок - на добавление, второй - на вытаскивание элемента из очереди. За счет локов, по сравнению с `ArrayBlockingQueue`, данный класс имеет высокую производительность, но для него необходимо большее количество памяти. Размер очереди задается через конструктор и по умолчанию равен `Integer.MAX_VALUE`.

## PriorityBlockingQueue

Многопоточная обертка над `PriorityQueue`. `Comparator` отвечает за то, по какой логике будет добавлен элемент. Первым же из очереди выходит самый наименьший элемент.

## SynchronousQueue

 Очередь работает по принципу FIFO(first-in-first-out). Каждая операция вставки блокирует поток “Producer”до тех пор, пока поток "Consumer" не вытащит элемент из очереди и наоборот, "Consumer" будет ждать пока "Producer" не вставит элемент.

# BlockingDeque

 Интерфейс, который описывает дополнительные методы для двунаправленной блокирующей очереди. Данные можно вставлять и вытаскивать с обеих сторон очереди.

## LinkedBlockingDeque

Двунаправленная блокирующая очередь на связанных нодах, реализованная как простой двунаправленный список с одним локом. Размер очереди задается через конструктор и по умолчанию равен `Integer.MAX_VALUE`.

# TransferQueue

Интерфейс интересен тем, что при добавлении элемента в очередь существует возможность заблокировать вставляющий поток Producer до тех пор, пока другой поток Consumer не вытащит элемент из очереди. Также можно добавить проверку на определенный тайм-аут или выставить проверку на наличие ожидающих Consumer. Как итог, мы получаем механизм передачи данных с поддержкой асинхронных и синхронных сообщений.

## LinkedTransferQueue

Реализация `TransferQueue` на основе алгоритма Dual Queues with Slack. Активно использует CAS (смотрите выше) и парковку потоков, когда они находятся в режиме ожидания.