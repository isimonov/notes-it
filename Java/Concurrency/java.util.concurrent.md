# Concurrent Collections

Набор коллекций для работы в многопоточной среде. Вместо базового враппера `Collections.synchronizedList` с блокированием доступа ко всей коллекции используются блокировки по сегментам данных или используются wait-free алгоритмы для параллельного чтения данных.

## CopyOnWriteArrayList

 Потокобезопасный аналог `ArrayList`, реализованный на основе *CopyOnWrite* алгоритмов. Операции `add`, `set`, `remove` в данной коллекции приводят к созданию новой копии внутреннего массива. Это гарантирует то, что мы не словим `ConcurrentModificationException`. Лучше использовать в случаях с минимальным количеством write операций.

## CopyOnWriteArraySet

Реализация интерфейса Set, использующая за основу `CopyOnWriteArrayList`.

## ConcurrentMap

Улучшенные реализации `HashMap` и `TreeMap` с поддержкой многопоточности и масштабируемости. Итераторы не кидают `ConcurrentModificationException` и представляют данные на определенный отрезок времени.

### ConcurrentHashMap

Данные представлены в виде сегментов, которые разбиты по hash'ам ключей. По итогу, если вам нужен доступ, то блокируется сегмент, а не объект.

### ConcurrentNavigableMap

Расширяет интерфейс _NavigableMap_ и возвращает _ConcurrentNavigableMap_.

### ConcurrentSkipListMap

Является аналогом `TreeMap` для многопоточности. Данные сортируются по ключу и гарантируется усредненная производительность log(N) для `containsKey`, `get`, `put`, `remove` и других похожих операций.

### ConcurrentSkipListSet

Имплементация интерфейса `Set` на основе `ConcurrentSkipListMap`.


# Queues

 неблокирующие и блокирующие очереди для работы в многопоточной среде. Неблокирующие очереди сосредоточены на скорости и работе без блокирования потоков. Блокирующие очереди подходят для работы, когда нужно "притормозить" потоки Producer или Consumer. Например, в той ситуации, когда не выполнены какие-то из условий, очередь пуста или переполнена, или же нет свободного Consumer'a.

## Non-Blocking Queues

Потокобезопасные и самое важное неблокирующие имплементации `Queue` на связанных нодах (linked nodes).

### ConcurrentLinkedQueue

Используется wait-free алгоритм, адаптированный для работы с garbage collector'ом. Этот алгоритм довольно эффективен и очень быстр, так как построен на CAS (compare and set). Метод `size()` может работать долго, так что лучше постоянно его не дергать.

### ConcurrentLinkedDeque

Deque расшифровывается как Double ended queue. Это означает, что данные можно добавлять и вытаскивать с обеих сторон. Соответственно, класс поддерживает оба режима работы: FIFO (First In First Out) и LIFO (Last In First Out).

На практике `ConcurrentLinkedDeque` стоит использовать в том случае, если обязательно нужно именно LIFO, так как за счет двунаправленности нод данный класс проигрывает по производительности наполовину по сравнению с `ConcurrentLinkedQueue`.

## Blocking Queues

Интерфейс `BlockingQueue<\E>` используется при большом количестве данных, когда `ConcurrentLinkedQueue` не хватает.

Когда потоки не справляются с поставленной задачей, ты легко можешь получить `OutOfMemmoryException`. И чтобы такие случаи не возникали, у нас для работы есть `BlockingQueue` c наличием разных методов для заполнения и работы с очередью и блокировками по условиям.

`BlockingQueue` не признает нулевых элементов (null) и вызывает `NullPointerException` при попытке добавить или получить такой элемент.

### ArrayBlockingQueue

Класс блокирующей очереди, построенный на классическом кольцевом буфере. Здесь нам доступна возможность управлять "честностью" блокировок. Если fair=false (по умолчанию), то очередность работы потоков не гарантируется.

### DelayQueue

Класс, который позволяет вытаскивать элементы из очереди только по прошествии некоторой задержки, определенной в каждом элементе через метод `getDelay` интерфейса `Delayed`.

### LinkedBlockingQueue

Блокирующая очередь на связанных нодах, реализованная на “two lock queue” алгоритме: первый лок - на добавление, второй - на вытаскивание элемента из очереди. За счет локов, по сравнению с `ArrayBlockingQueue`, данный класс имеет высокую производительность, но для него необходимо большее количество памяти. Размер очереди задается через конструктор и по умолчанию равен `Integer.MAX_VALUE`.

### PriorityBlockingQueue

Многопоточная обертка над `PriorityQueue`. `Comparator` отвечает за то, по какой логике будет добавлен элемент. Первым же из очереди выходит самый наименьший элемент.

### SynchronousQueue

 Очередь работает по принципу FIFO(first-in-first-out). Каждая операция вставки блокирует поток “Producer”до тех пор, пока поток "Consumer" не вытащит элемент из очереди и наоборот, "Consumer" будет ждать пока "Producer" не вставит элемент.

## BlockingDeque

 Интерфейс, который описывает дополнительные методы для двунаправленной блокирующей очереди. Данные можно вставлять и вытаскивать с обеих сторон очереди.

### LinkedBlockingDeque

Двунаправленная блокирующая очередь на связанных нодах, реализованная как простой двунаправленный список с одним локом. Размер очереди задается через конструктор и по умолчанию равен `Integer.MAX_VALUE`.

## TransferQueue

Интерфейс интересен тем, что при добавлении элемента в очередь существует возможность заблокировать вставляющий поток Producer до тех пор, пока другой поток Consumer не вытащит элемент из очереди. Также можно добавить проверку на определенный тайм-аут или выставить проверку на наличие ожидающих Consumer. Как итог, мы получаем механизм передачи данных с поддержкой асинхронных и синхронных сообщений.

### LinkedTransferQueue

Реализация `TransferQueue` на основе алгоритма Dual Queues with Slack. Активно использует CAS (смотрите выше) и парковку потоков, когда они находятся в режиме ожидания.


# Synchronizers

Вспомогательные утилиты для синхронизации потоков, которые дают возможность разработчику регулировать и/или ограничивать работу потоков и предоставляют более высокий уровень абстракции, чем основные примитивы языка (мониторы).

## Semaphore

Синхронизатор Semaphore реализует шаблон синхронизации Семафор. Доступ управляется с помощью счётчика: изначально значение счётчика равно `int permits`, когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, когда поток его покидает, то увеличивается. Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из блока (в качестве примера из жизни с `permits = 1`, можно привести очередь в кабинет в поликлинике: когда пациент покидает кабинет, мигает лампа, и заходит следующий пациент). В конструктор этого класса (`Semaphore(int permits)` или `Semaphore(int permits, boolean fair)`) обязательно передается количество потоков, которому семафор будет разрешать одновременно использовать заданный ресурс.

## CountDownLatch

CountDownLatch (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут «отпущены», чтобы продолжить свою деятельность. В конструктор CountDownLatch (`CountDownLatch(int count)`) обязательно передается количество операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки.

## CyclicBarrier

CyclicBarrier реализует шаблон синхронизации Барьер. Циклический барьер является точкой синхронизации, в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». В конструктор барьера (CyclicBarrier(int parties) и CyclicBarrier(int parties, Runnable barrierAction)) обязательно передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, когда стороны встретились, но перед тем когда они будут «отпущены».

Барьер похож на CountDownLatch, но главное различие между ними в том, что вы не можете заново использовать «замок» после того, как его счётчик достигнет нуля, а барьер вы можете использовать снова, даже после того, как он сломается. CyclicBarrier является альтернативой метода `join()`, который «собирает» потоки только после того, как они выполнились.

## Exchanger<\V>

Exchanger (обменник) может понадобиться, для того, чтобы обменяться данными между двумя потоками в определенной точки работы обоих потоков. Обменник - обобщенный класс, он параметризируется типом объекта для передачи.

Обменник является точкой синхронизации пары потоков: поток, вызывающий у обменника метод `exchange()` блокируется и ждет другой поток. Когда другой поток вызовет тот же метод, произойдет обмен объектами: каждая из них получит аргумент другой в методе `exchange()`. Стоит отметить, что обменник поддерживает передачу `null` значения. Это дает возможность использовать его для передачи объекта в одну сторону, или, просто как точку синхронизации двух потоков.

## Phaser

Phaser (фазер), как и CyclicBarrier, является реализацией шаблона синхронизации Барьер, но, в отличии от CyclicBarrier, предоставляет больше гибкости. Этот класс позволяет синхронизировать потоки, представляющие отдельную фазу или стадию выполнения общего действия. Как и CyclicBarrier, Phaser является точкой синхронизации, в которой встречаются потоки-участники. Когда все стороны прибыли, Phaser переходит к следующей фазе и снова ожидает ее завершения.

[Справочник по синхронизаторам](https://habr.com/ru/articles/277669/)


# Executors

`ExecutorService` исполняет асинхронный код в одном или нескольких потоках. Создание инстанса ExecutorService'а делается либо вручную через конкретные имплементации (`ScheduledThreadPoolExecutor` или `ThreadPoolExecutor`), но проще будет использовать фабрики класса `Executors`.

## ThreadPoolExecutor

```java
ExecutorService service1 = Executors.newFixedThreadPool(2);
ExecutorService service3 = Executors.newSingleThreadExecutor();
ExecutorService service2 = Executors.newCachedThreadPool();
ExecutorService service4 = Executors.newScheduledThreadPool(3);
```

### FixedThreadPool

*FixedThreadPool* - обычный фиксированный пул потоков.

### SingleThreadExecutor

- Сервис выполняет за раз только одну задачу.
- Если мы отправляем N задач на исполнение, все N задач одна за другой будет выполняться одним потоком.
- Если поток будет прерван, то создастся новый поток для выполнения остальных задач.

### Cached Thread Executor

*Cached Thread Executor* - кэширует потоки, отсюда и название. Он держит активными (но не используемыми) потоки в течение ограниченного количества времени, для того чтобы использовать эти потоки для выполнения новых задач.

```java
public static ExecutorService newCachedThreadPool() {
	return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
}
```

## ScheduledThreadPoolExecutor

*ScheduledThreadPoolExecutor* - выполнение задач по расписанию.

```java
ExecutorService service = Executors.newScheduledThreadPool(3);
Runnable task = () -> { System.out.println(Thread.currentThread().getName()); };
// after 1 second every 2 seconds
service.scheduleAtFixedRate(task, 1, 2, TimeUnit.SECONDS);
```


# Locks

Гибкие механизмы синхронизации потоков по сравнению с базовыми `synchronized`, `wait`, `notify`, `notifyAll`. Классы блокировок реализуют интерфейс `Lock`, который определяет следующие методы:

- `void lock()`: ожидает, пока не будет получена блокировка
- `void lockInterruptibly() throws InterruptedException`: ожидает, пока не будет получена блокировка, если поток не прерван
- `boolean tryLock()`: пытается получить блокировку, если блокировка получена, то возвращает true. Если блокировка не получена, то возвращает false. В отличие от метода `lock()` не ожидает получения блокировки, если она недоступна
- `void unlock()`: снимает блокировку
- `Condition newCondition()`: возвращает объект Condition, который связан с текущей блокировкой

## ReentrantLock

 Реентерабельная блокировка. Реентрабильность - программа разработана таким образом, что одна и та же копия инструкций программы в памяти может быть совместно использована несколькими пользователями или процессами

```java
private final Lock R_LOCK = ReentrantLock();
R_LOCK.lock();
try { //тут происходят какие-то действия }
finally { R_LOCK.unlock(); }
```

## ReadWriteLock

`ReadWriteLock` - интерфейс для создания read/write локов. Локи необычайно полезны, когда в системе много операций чтения и мало операций записи. `ReadWriteLock` имеет два основных метода: `readLock()` и `writeLock()`.

### ReentrantReadWriteLock

`ReentrantReadWriteLock` - используется в многопоточных сервисах и кешах, имеют хороший прирост производительности по сравнению с блоками synchronized. По сути, класс работает в 2-х взаимоисключающих режимах: много читателей читают данные в параллель и когда только 1 райтер пишет данные.


# Atomics

Классы, которые могут поддерживать атомарные операции над примитивами и ссылками. Atomics можно разделить на 4 группы.

## Atomic boolean, integer, long и ссылки

- AtomicBoolean
- AtomicInteger
- AtomicLong
- AtomicReference

Классы этой группы содержат метод **compareAndSet**, принимающий 2 аргумента : предполагаемое текущее и новое значения. Метод устанавливает объекту новое значение, если текущее равно предполагаемому, и возвращает true. Если текущее значение изменилось, то метод вернет false и новое значение не будет установлено.  

Кроме этого, классы имеют метод **getAndSet**, который безусловно устанавливает новое значение и возвращает старое.  

Классы AtomicInteger и AtomicLong имеют также методы инкремента/декремента/добавления нового значения.

## Atomic массивы integer, long и ссылок

- AtomicIntegerArray
- AtomicLongArray
- AtomicReferenceArray

Элементы массивов могут быть изменены атомарно.

## Классы для обновления полей с использованием reflection

- AtomicIntegerFieldUpdater
- AtomicLongFieldUpdater
- AtomicReferenceFieldUpdater

Гарантии метода CompareAndSet в этих классах слабее, чем в других атомарных классах. Поскольку эти классы не могут гарантировать, что все виды использования поля подходят для целей атомарного доступа, он может гарантировать атомарность только в отношении других вызовов метода CompareAndSet, установленных в том же средстве обновления.

## Atomic-классы для реализации некоторых алгоритмов

- AtomicStampedReference - предоставляет нам как переменную ссылки на объект, так и штамп, который мы можем читать и записывать атомарно. Мы можем думать о штампе как о временной отметке или номере версии. Добавление штампа позволяет нам обнаружить, когда другой поток изменил общую ссылку с исходной ссылки A на новую ссылку B и обратно на исходную ссылку A.
- AtomicMarkableReference - инкапсулирует как ссылку на объект , так и логический флаг. Эти два поля связаны друг с другом и могут обновляться атомарно , либо вместе, либо по отдельности. Также класс может быть возможным решением [проблемы ABA](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_ABA).
