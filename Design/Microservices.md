# API Gateway

Выступая в качестве единой точки входа для всех клиентских запросов, API-шлюз упрощает доступ к вашим микросервисам, обеспечивая бесшовное взаимодействие между клиентами и сервисами. Это решает следующие задачи:

- Помогает в агрегации ответов от нескольких микросервисов, сокращая количество обращений между клиентами и сервисами. Это приводит к повышению производительности и удобства использования.
- Позволяет вам реализовать общие функции, такие как аутентификация, логирование и ограничение скорости, в одном месте, способствуя согласованности и снижению избыточности.
Инструменты: Spring Cloud Gateway (с Spring Cloud DiscoveryClient, LoadBalancerClient Filter), Kubernetes Gateway API
# Service Discovery 

Service Discovery позволяет сервисам динамически находить друг друга, обеспечивая бесперебойное взаимодействие и уменьшая необходимость вручную настраивать конфигурацию.

Паттерн Service Discovery основан на двух основных подходах: обнаружение на стороне клиента и обнаружение на стороне сервера. Обнаружение на стороне клиента предполагает, что клиент запрашивает реестр сервисов, чтобы найти местоположение целевого сервиса, в то время как обнаружение на стороне сервера полагается на балансировщик нагрузки для маршрутизации запросов к соответствующему сервису. Инструменты: Netflix Eureka, Consul и Kubernetes.
# Circuit breaking

Шаблон Circuit Breaker отслеживает сбои и предотвращает достижение запросов до неработающего сервиса, давая ему время для восстановления и защищая всю систему от полного отказа.

С помощью Circuit Breakers вы можете изолировать неправильно работающий сервис и предотвратить дальнейшую деградацию функционирования системы, обеспечивая её устойчивость и стабильность.

Выделяют три состояния сircuit breaking:

- Closed state
- Open state
- Half-open state
# Load Balancing

Балансировка нагрузки может быть реализована с использованием различных алгоритмов, таких как:

- round-robin
- least connections
- weighted round-robin

Инструменты: NGINX и HAProxy, Ingress
# Bulkhead

Шаблон Bulkhead (перегородка) (изоляция от сбоев) изолирует сервисы и ресурсы, гарантируя, что сбой в одном сервисе не приведет к выходу из строя всей системы.

Проектирование и внедрение Bulkheads включает создание отдельных ресурсов для каждого сервиса, таких как отдельные пулы потоков или подключения к базе данных. Таким образом, даже если один сервис исчерпывает свои ресурсы, другие сервисы остаются незатронутыми. Реальные примеры реализации Bulkheads включают распределение ресурсов функций AWS Lambda и использование пулов подключений в базах данных.

[Подробнее](https://learn.microsoft.com/ru-ru/azure/architecture/patterns/bulkhead)
# CQRS

Шаблон CQRS (Command and Query Responsibility Segregation) про повышение производительности микросервисов за счет разделения задач. CQRS разделяет операции чтения и записи ваших сервисов, позволяя вам независимо настраивать каждый аспект для достижения максимальной эффективности.

В традиционных архитектурах совмещение операций чтения и записи может привести к снижению производительности и увеличению сложности. С помощью CQRS вы можете оптимизировать каждую операцию по отдельности, что приведет к улучшению производительности и упрощению обслуживания.

Внедрение CQRS предполагает разделение ваших сервисов на две отдельные части: одну для обработки команд (операции записи), а другую — для обработки запросов (операции чтения). Такое разделение позволяет применять разные стратегии масштабирования, кэширования и работы с базами данных для каждого типа операций.

# Event-Driven Architecture Pattern

Event-Driven Architecture Pattern - реагирование в реальном времени. Этот шаблон использует события для запуска действий в ваших службах, обеспечивая реагирование в режиме реального времени и способствуя независимости между сервисами.

Используя события в качестве триггеров, вы можете свести к минимуму прямые зависимости между службами, что позволит повысить гибкость и упростить масштабирование системы.

Шаблон по сути представляет из себя использование событийной шины, основанной на брокерах обмена сообщениями.

Инструменты: Apache Kafka, RabbitMQ.
# Saga

Saga - выполнение распределенных транзакций. Паттерн Saga предлагает надежное решение для работы с распределенными транзакциями, обеспечивая согласованность данных при сохранении автономии ваших сервисов.

В архитектуре микросервисов транзакции часто охватывают несколько сервисов, что делает традиционные ACID-транзакции неэффективными. Шаблон Saga предоставляет способ управления такими сложными сценариями, сохраняя при этом преимущества микросервисной архитектуры.

Реализация данного шаблона включает разделение распределенной транзакции на серию локальных транзакций, каждая из которых сопровождается событием или сообщением. Если локальная транзакция завершается неудачно, выполняются компенсирующие транзакции, чтобы отменить уже выполненные шаги и сохранить согласованность данных. Инструменты, такие как Eventuate и Axon, предоставляют встроенную поддержку для реализации Saga в вашей архитектуре микросервисов.

Существует два распространенных подхода к реализации саги: 

- хореография - нет единой точки управления сагой, реализуется через брокер сообщений, сервисы сами реагируют на сбои, слушая сообщения 
- оркестрация - есть оркестрирующий сагу сервис, в случае сбоя, явным образом вызывает компенсирующие действия
# Retry

Retry - корректное восстановление после ошибок. Этот шаблон предусматривает автоматическое повторение неудачной операции, увеличивая вероятность успешного выполнения и минимизируя влияние временных сбоев.

В экосистеме микросервисов неизбежны временные сбои, такие как сбои в сети или таймаут ожидания сервиса. Шаблон Retry позволяет вашим сервисам корректно восстанавливаться после таких проблем, повышая общую стабильность системы.

Ключевым моментом успешной реализации является определение подходящей стратегии повторных попыток. Эта стратегия должна включать факторы, такие как максимальное количество повторов, задержку между повторами и, возможно, экспоненциальное замедление. Библиотеки, такие как Polly, Resilience4j и Spring Retry, предоставляют встроенную поддержку для реализации шаблона Retry в ваших микросервисах.
# Backends for Frontends Pattern (BFF)

BFF - оптимизация UX с помощью агрегации сервисов. Этот шаблон предусматривает создание отдельных бэкэнд-сервисов для каждого интерфейса, обеспечивая оптимальную производительность и настраиваемый пользовательский опыт для каждой платформы.

Этот шаблон предусматривает создание отдельных бэкэнд-сервисов для каждого фронтенда, обеспечивая оптимальную производительность и настраиваемый пользовательский опыт для каждой платформы.

В микросервисной архитектуре один бэкэнд-сервис может не удовлетворять разнообразным требованиям различных интерфейсов. Шаблон BFF позволяет настроить бэкэнд-сервисы для каждой платформы, повышая производительность и удобство пользователей.

Для реализации шаблона BFF вы создаете отдельные серверные сервисы для каждого фронтенда (например, веб, мобильное приложение, IoT), собирая и адаптируя данные специально под требования каждой платформы. Такие инструменты, как GraphQL, Apollo Server и Express. js, могут облегчить создание пользовательских серверных служб для ваших интерфейсов
# Sidecar

Sidecar (коляска, видимо а-ля мотоциклетная) - модульная функциональность для микросервисов. Паттерн Sidecar позволяет добавлять дополнительные компоненты к вашим сервисам, предоставляя модульную функциональность без изменения основного сервиса.

В микросервисной архитектуре крайне важно сохранять независимость сервисов. Шаблон Sidecar позволяет добавлять новые функции и задачи, не влияя на основной сервис, а также сохраняя модульность и удобство сопровождения.

Реализация шаблона Sidecar включает развертывание отдельного контейнера рядом с основным сервиса. Этот дополнительный контейнер обрабатывает конкретные задачи, такие как логирование, мониторинг или безопасность, позволяя основному сервису сосредоточиться на его основной функциональности. Примеры реализации Sidecar включают прокси-сервер Envoy в сервисной сети и контейнер для логирования Fluentd.
# Strangler

Strangler (душитель) - из монолита в микросервисы. Данный шаблон позволяет постепенно заменить монолитную систему микрослужбами, обеспечивая плавный и безопасный переход.

Переход от монолитной архитектуры к микросервисам может быть сложным и рискованным. Шаблон Strangler позволяет проводить поэтапную замену, сводя к минимуму время простоя и риск, сохраняя при этом непрерывность бизнеса.

Реализация паттерна начинается с определения основной функциональности в монолитной системе. После этого создается новый микросервис для обработки этой функциональности и перенаправления запросов с новому сервису с помощью API-шлюза или прокси. Процесс повторяется для остального функционала, пока монолит не превратится в микросервисную архитектуру.
# Timeout

Устанавливаем таймауты, чтобы не ждать ответа бесконечно.
# Deadlines

Регламентирует время обработки запроса в микросервисной среде. Работает примерно по следующему принципу. Вызывающая система передаёт в заголовке дату и время до которого операция должна быть завершена. Далее этот значение транслируется по цепочке вызовов. Если на каком то этапе время выполнения превысит заданный deadline, сервис, который это обнаружит, даже не станет пытаться обрабатывать запрос и вернёт ошибку.
# Rate limiting

Rate limiting - ограничение скорости обработки запросов.

Известны три основных параметра для управления рейт-лимитом:

- Количество запросов - максимальное количество запросов, которое клиент может отправить за определенный период времени (например, 100 запросов в минуту).
- Временной интервал - период времени, в течение которого можно отправлять заданное количество запросов (например, в течение 1 минуты).
- Время сброса - момент, когда счетчик запросов сбрасывается и клиенту снова разрешается отправлять запросы (например, каждую минуту).

Для реализации рейт-лимитирования сервер может использовать различные техники, например, сохранять счетчики запросов в оперативной памяти сервера, базе данных или внешнем хранилище ключ-значение. Кроме того, сервер может отправлять клиенту специальные заголовки (например, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset), содержащие информацию о текущем состоянии рейт-лимита.

Использование рейт-лимитирования позволяет предотвратить чрезмерную нагрузку на сервер и улучшить производительность системы в целом. Также рейт-лимитирование может использоваться для защиты от DDoS-атак и предотвращения злоумышленнической активности.

[Подробнее на Habr](https://habr.com/ru/articles/448438/)
# Rich client

Rich client в микросервисной архитектуре предполагает наличие некого самодостаточного независимого от сервера функциональности, позволяющей обслуживать некоторые запросы, не прибегая к жёсткой зависимости от необходимости вызывать внешнюю логику.

Этот подход может быть представлен как на непосредственно UI клиенте, так и на промежуточных сервисах. В последнем случае может быть реализован может быть виде некого SDK, который подключается к клиентской системе.

Тут скорее имеется в виду, что есть некое непрямое косвенное взаимодействие с вызываемым сервисом, например, использую отложенную синхронизацию.
# Dummy (Fallback)

Шаблон тыква или резервный. Предполагает наличие сервиса, реализующего минимально возможный функционал для клиентского приложения. В случае возникновения серьёзной аварии в системе, данный сервис активизируется и на него переводится весь трафик до момента восстановления основного функционала. Таким образом можно нивелировать негативные последствия для клиентского опыта.

[12 шаблонов микросервисов](https://vc.ru/u/1969656-dmitriy/725850-12-shablonov-mikroservisov-kotorye-ya-hotel-by-znat-do-sobesedovaniya-po-sistemnomu-dizaynu) [Оригинал](https://levelup.gitconnected.com/12-microservices-pattern-i-wish-i-knew-before-the-system-design-interview-5c35919f16a2)